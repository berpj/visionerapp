'use strict';function get_gps_coordinates (data_latitude, data_longitude) {  var latitude = 0;  var longitude = 0;  latitude = data_latitude[0] + (data_latitude[1] / 60) + (data_latitude[2] / 3600);  longitude = data_longitude[0] + (data_longitude[1] / 60) + (data_longitude[2] / 3600);  return [latitude, longitude]}function get_country (format, old_full_path, callback) {  var ExifImage = require('exif').ExifImage;  var request = require("request");  try {    new ExifImage({ image : old_full_path }, function (error, exifData) {      if (format.includes('country')) {        var country = 'unknown';        var coordinates = get_gps_coordinates(exifData.gps.GPSLatitude, exifData.gps.GPSLongitude);        request({          url: 'https://maps.googleapis.com/maps/api/geocode/json?latlng=' + coordinates[0].toString() + ',' + coordinates[1].toString(),          json: true        }, function (error, response, data) {          if (!error && response.statusCode === 200) {            country = data.results.filter(function(place) { return place['types'][0] == 'country' })[0].address_components[0].long_name;            callback(null, country);          }          else {            callback(null, 'unknown');          }        });      }    });  }  catch (error) {    console.log('Error: ' + error.message);    callback(null, 'unknown');  }}function get_locality (format, old_full_path, callback) {  var ExifImage = require('exif').ExifImage;  var request = require("request");  try {    new ExifImage({ image : old_full_path }, function (error, exifData) {      if (format.includes('country')) {        var locality = 'unknown';        var coordinates = get_gps_coordinates(exifData.gps.GPSLatitude, exifData.gps.GPSLongitude);        request({          url: 'https://maps.googleapis.com/maps/api/geocode/json?latlng=' + coordinates[0].toString() + ',' + coordinates[1].toString(),          json: true        }, function (error, response, data) {          if (!error && response.statusCode === 200) {            locality = data.results.filter(function(place) { return place['types'][0] == 'locality' })[0].address_components[0].long_name;            callback(null, locality);          }          else {            callback(null, 'unknown');          }        });      }    });  }  catch (error) {    console.log('Error: ' + error.message);    callback(null, 'unknown');  }}function get_date (format, old_full_path, callback) {  callback(null, 'unknown');}function get_label (format, old_full_path, callback) {  callback(null, 'unknown');}function rename_file (error, results, format, old_full_path, callback_ipc) {  var path = require('path');  var fs = require('fs');  var extname = path.extname(old_full_path).toLowerCase();  var dir = path.dirname(old_full_path) + '/';  var old_filename = path.basename(old_full_path).toLowerCase();  var new_filename = format.toLowerCase();  var new_basename = path.basename(new_filename, '.jpg');  console.log(results);  fs.rename(old_full_path, dir + new_basename + '' + '.jpg');  callback_ipc();}const electron = require('electron');// Module to control application life.const app = electron.app;// Module to create native browser window.const BrowserWindow = electron.BrowserWindow;// Keep a global reference of the window object, if you don't, the window will// be closed automatically when the JavaScript object is garbage collected.let mainWindow;function createWindow () {  const ipcMain = require('electron').ipcMain;  var async = require("async");  mainWindow = new BrowserWindow({width: 600, height: 530, resizable: false});  mainWindow.loadURL('file://' + __dirname + '/index.html');  ipcMain.on('asynchronous-message', function(event, format, files) {    for (var i = 0, len = files.length; i < len; i++) {      var callback_ipc = event.sender.send('asynchronous-reply', 'done');      async.series([        function(callback) { get_country(format, files[i], callback) },        function(callback) { get_locality(format, files[i], callback) },        function(callback) { get_date(format, files[i], callback) },        function(callback) { get_label(format, files[i], callback) }      ], function(error, results) { rename_file(error, results, format, files[i], callback_ipc) });    }  });  //mainWindow.webContents.openDevTools();  mainWindow.on('closed', function() {    mainWindow = null;  });}// This method will be called when Electron has finished// initialization and is ready to create browser windows.app.on('ready', createWindow);// Quit when all windows are closed.app.on('window-all-closed', function () {  // On OS X it is common for applications and their menu bar  // to stay active until the user quits explicitly with Cmd + Q  if (process.platform !== 'darwin') {    app.quit();  }});app.on('activate', function () {  // On OS X it's common to re-create a window in the app when the  // dock icon is clicked and there are no other windows open.  if (mainWindow === null) {    createWindow();  }});